\name{spatstat-internal}
\alias{[.hyperframe}
\alias{[<-.hyperframe}
\alias{$.hyperframe}
\alias{$<-.hyperframe}
\alias{acedist.show}
\alias{acedist.noshow}
\alias{affinexy}
\alias{anycrossing.psp}
\alias{apply23sum}
\alias{area.xypolygon}       
\alias{AsymmHausdorff.psp}
\alias{as.breakpts}
\alias{as.data.frame.hyperframe}
\alias{as.fv}
\alias{as.list.hyperframe}
\alias{as.polygonal}
\alias{as.units}
\alias{beachcolours}
\alias{bind.fv}
\alias{bdrylength.xypolygon} 
\alias{bdry.mask} 
\alias{breakpts}
\alias{breakpts.from.r}
\alias{bt.frame}
\alias{cartesian}
\alias{cbind.hyperframe}
\alias{cellmiddles}
\alias{checkfields}          
\alias{check.hist.lengths}
\alias{check.named.vector}
\alias{clip.psp}
\alias{cliprect.psp}
\alias{clippoly.psp}
\alias{closepairs}
\alias{crosspairs}
\alias{cobble.xy}
\alias{commasep}
\alias{compatible.units}
\alias{countingweights}
\alias{damaged.ppm}
\alias{default.expand}
\alias{default.clipwindow}
\alias{default.n.tiling}
\alias{default.ntile}
\alias{diagnose.ppm.engine}
\alias{dimnames.fasp}               
\alias{dimnames<-.fasp}               
\alias{distpl}               
\alias{distppl}
\alias{distppll}
\alias{divisors}
\alias{do.call.matched}
\alias{edge.Ripley}
\alias{edge.Trans}
\alias{ensure2vector}
\alias{equals.quad}          
\alias{eratosthenes}
\alias{erode.mask}
\alias{even.breaks.owin}
\alias{exactdt}              
\alias{exactPdt}
\alias{extractAIC.ppm}
\alias{fasp}
\alias{findmarktype}
\alias{fii}
\alias{fillNA}
\alias{FormatFaspFormulae}
\alias{formula.ppm}
\alias{formula.kppm}
\alias{fv}
\alias{fvnames}
\alias{greatest.common.divisor}
\alias{getfields}
\alias{getglmdata}
\alias{getglmfit}
\alias{gridindex}            
\alias{grid1index}
\alias{handle.r.b.args}
\alias{handle.rshift.args}
\alias{ho.engine}
\alias{identical.formulae}
\alias{inside.xypolygon}     
\alias{intersect.ranges}     
\alias{intX.owin}     
\alias{intX.xypolygon}     
\alias{intY.owin}     
\alias{intY.xypolygon}     
\alias{is.cadlag}
\alias{is.data}
\alias{is.fv}
\alias{is.hyperframe}
\alias{is.interact}
\alias{is.marked.default}    
\alias{is.marked.quad}    
\alias{is.multitype.quad}    
\alias{is.multitype.default}    
\alias{is.prime}
\alias{is.poisson.interact}
\alias{is.poisson.ppm}
\alias{is.stationary.ppm}
\alias{kstestEngine}
\alias{Kborder.engine}
\alias{Kount}
\alias{Kwtsum}               
\alias{Kmulti.inhom}               
\alias{killinteraction}
\alias{least.common.multiple}
\alias{levels<-.im}
\alias{lookup.im}
\alias{majorminorversion}
\alias{make.even.breaks}
\alias{makeunits}
\alias{markformat}
\alias{markformat.ppp}
\alias{markformat.psp}
\alias{markspace.integral}
\alias{marks}           
\alias{marks.ppp}           
\alias{marks.psp}           
\alias{marks.quad}           
\alias{marks<-}           
\alias{marks<-.ppp}           
\alias{\%mapp\%}
\alias{markappendop}
\alias{marksubset}
\alias{markreplicateop}
\alias{\%mrep\%}
\alias{marksubsetop}
\alias{\%msub\%}
\alias{matcolall}
\alias{matcolany}
\alias{matcolsum}
\alias{matrixsample}
\alias{matrowall}
\alias{matrowany}
\alias{matrowsum}
\alias{maxflow}
\alias{meanX.owin}
\alias{meanY.owin}
\alias{mkcor}
\alias{mpl.engine}
\alias{mpl.get.covariates}
\alias{mpl.prepare}
\alias{MultiPair.checkmatrix}
\alias{names.hyperframe}
\alias{names<-.hyperframe}
\alias{nearest.pixel}
\alias{newstyle.coeff.handling}
\alias{no.trend.ppm}
\alias{n.quad}
\alias{numalign}
\alias{outdated.interact}
\alias{overlap.owin}
\alias{overlap.trapezium}
\alias{overlap.xypolygon}    
\alias{owinpolycheck}
\alias{param.quad}
\alias{paren}
\alias{pickoption}
\alias{pixellate}
\alias{pixelquad}
\alias{ploterodewin}
\alias{ploterodeimage}
\alias{plot.fii}
\alias{plot.kstest}
\alias{plot.minconfit}
\alias{plot.pppmatching}
\alias{plot.profilepl}
\alias{plot.qqppm}
\alias{plot.quadratcount}
\alias{plot.quadrattest}
\alias{polynom}
\alias{pppdist.mat}
\alias{pppdist.prohorov}
\alias{primefactors}       
\alias{print.bt.frame}
\alias{print.diagppm}
\alias{print.envelope}
\alias{print.fasp}       
\alias{print.fii}       
\alias{print.fv}       
\alias{print.hyperframe}
\alias{print.interact}       
\alias{print.isf}
\alias{print.kppm}
\alias{print.minconfit}
\alias{print.plotppm}
\alias{print.pppmatching}
\alias{print.profilepl}
\alias{print.qqppm}
\alias{print.rmhcontrol}
\alias{print.rmhmodel}
\alias{print.rmhstart}
\alias{print.rmhseed}
\alias{print.summary.fii}
\alias{print.summary.hyperframe}
\alias{print.summary.listof}
\alias{print.summary.owin}
\alias{print.summary.ppp}
\alias{print.summary.psp}
\alias{print.summary.splitppp}
\alias{print.summary.units}
\alias{print.units}
\alias{prolongseq}
\alias{quad}
\alias{quadrat.breaks}
\alias{quadrat.countEngine}
\alias{quadrat.testEngine}
\alias{quadscheme.replicated}
\alias{quadscheme.spatial}
\alias{pointgrid}
\alias{rasterx.im}
\alias{rastery.im}
\alias{reach.fii}
\alias{rebound.ppp}
\alias{rebound.psp}
\alias{rebound.owin}
\alias{reincarnate.interact}
\alias{rescale.units}
\alias{resid4plot}
\alias{resid1plot}
\alias{resid1panel}
\alias{resolve.defaults}
\alias{restrict.mask}
\alias{reverse.xypolygon}    
\alias{revcumsum}    
\alias{rmax.rule}
\alias{rotxy}
\alias{row.names.hyperframe}
\alias{row.names<-.hyperframe}
\alias{runifpoispp}          
\alias{runifrect}
\alias{rmhResolveTypes}
\alias{rmhcontrol.rmhcontrol}
\alias{rmhcontrol.list}
\alias{rmhEngine}
\alias{rmhmodel.rmhmodel}
\alias{rmhseed}
\alias{rmhstart.rmhstart}
\alias{rmhstart.list}
\alias{rmpoint.I.allim}
\alias{rpoint.multi}
\alias{safelookup}
\alias{second.moment.calc}
\alias{shiftxy}              
\alias{spatstat.rawdata.location}
\alias{sp.foundclass}
\alias{sp.foundclasses}
\alias{stratrand}
\alias{suffloc}
\alias{suffstat.generic}
\alias{suffstat.poisson}
\alias{summary.envelope}
\alias{summary.fii}
\alias{summary.hyperframe}
\alias{summary.profilepl}
\alias{summary.pppmatching}
\alias{summary.units}
\alias{sympoly}
\alias{terms.ppm}
\alias{terms.kppm}
\alias{termsinformula}
\alias{test.crossing.psp}
\alias{test.selfcrossing.psp}
\alias{tilecentroids}        
\alias{trim.mask}        
\alias{unitname.default}
\alias{unitname<-.default}
\alias{update.interact}
\alias{valid.ppm}        
\alias{validate.mask}        
\alias{validate.quad}        
\alias{variablesinformula}        
\alias{versionstring.interact}
\alias{versionstring.ppm}
\alias{versionstring.spatstat}
\alias{verifyclass}
\alias{verify.xypolygon}
\alias{whist}               
\alias{w.quad}               
\alias{x.quad}
\alias{y.quad}
\alias{xypolygon2psp}
\alias{xypolyselfint}
\title{Internal spatstat functions}
\description{
  Internal spatstat functions.
}
\usage{
\method{[}{hyperframe}(x, i, j, drop=FALSE, ...)
\method{[}{hyperframe}(x, i, j) <- value
\method{$}{hyperframe}(x, name)
\method{$}{hyperframe}(x, i) <- value
acedist.show(X, Y, n, d, timelag = 0)
acedist.noshow(X, Y, n, d)
affinexy(X, mat = diag(c(1, 1)), vec = c(0, 0))
anycrossing.psp(A,B)
apply23sum(x)
area.xypolygon(polly)
AsymmHausdorff.psp(X, Y, method="Fortran")
as.breakpts(\dots)
\method{as.data.frame}{hyperframe}(x, row.names = NULL,
                                  optional = FALSE, ..., 
                                  discard=TRUE, warn=TRUE)
as.fv(x)
\method{as.list}{hyperframe}(x, ...)
as.polygonal(W)
as.units(s)
beachcolours(heightrange, sealevel, monochrome, ncolours)
bind.fv(x, y, labl, desc, preferred)
bdrylength.xypolygon(polly)
bdry.mask(W)
breakpts(val, maxi, even = FALSE, npos = NULL, step = NULL)
breakpts.from.r(r)
bt.frame(Q, trend=~1, interaction=NULL, ..., covariates=NULL,
         correction="border", rbord=0, use.gam=FALSE, allcovar=FALSE)
cartesian(pp, markset, fac = TRUE)
cbind.hyperframe(...)
cellmiddles(W, nx, ny, npix, gi)
checkfields(X,L)          
check.hist.lengths(hist,breaks)
check.named.vector(x, nam)
clip.psp(x, window, check=TRUE)
cliprect.psp(x, window)
clippoly.psp(s, window)
closepairs(X,rmax)
crosspairs(X,Y,rmax)
cobble.xy(x, y, f, fatal)
commasep(x)
compatible.units(x, y, coerce=TRUE)
countingweights(id, areas, check = TRUE)
damaged.ppm(object)
default.expand(object, m, epsilon)
default.clipwindow(object, epsilon)
default.n.tiling(X, nd, ntile, npix, verbose)
default.ntile(X)
diagnose.ppm.engine(object, \dots, type="eem", typename, opt,
                         sigma=NULL, rbord = reach(object), compute.sd=TRUE,
                         compute.cts=TRUE, rv=NULL, oldstyle=FALSE)
\method{dimnames}{fasp}(x)
\method{dimnames}{fasp}(x) <- value
distpl(p, l)               
distppl(p, l)
distppll(p, l, mintype=0, method="Fortran", listit=FALSE)
divisors(n)
do.call.matched(fname, arglist, funargs, extrargs)
edge.Ripley(X, r, W, method)
edge.Trans(X, Y, W, exact, paired, trim)
ensure2vector(x)
equals.quad(Q)          
eratosthenes(nmax)
erode.mask(w,r)
even.breaks.owin(w)
exactdt(X, \dots)              
exactPdt(w)
\method{extractAIC}{ppm}(fit, scale, k, \dots)
fasp(fns, which, formulae, dataname, title, rowNames, colNames)
findmarktype(x)
fii(interaction, coefs, Vnames)
fillNA(x, value)
FormatFaspFormulae(f, argname)
\method{formula}{ppm}(x, \dots)
\method{formula}{kppm}(x, \dots)
fv(x, argu, ylab, valu, fmla, alim, labl, desc, unitname)
fvnames(X, a)
greatest.common.divisor(n,m)
getfields(X, L, fatal = TRUE)
getglmdata(object)
getglmfit(object)
gridindex(x, y, xrange, yrange, nx, ny)            
grid1index(x, xrange, nx)
handle.r.b.args(r = NULL, breaks = NULL, window, eps = NULL, rmaxdefault)
handle.rshift.args(W, \dots, radius, width, height, edge, clip, edgedefault)
ho.engine(model, \dots, nsim, nrmh, start, control, verb)
identical.formulae(x,y)
inside.xypolygon(pts, polly, test01 = TRUE, method="Fortran")
intersect.ranges(a,b)
intX.owin(w)
intX.xypolygon(polly)
intY.owin(w)
intY.xypolygon(polly)
is.cadlag(s)
is.data(Q)
is.fv(x)
is.hyperframe(x)
is.interact(x)
\method{is.marked}{default}(\dots)  
\method{is.marked}{quad}(X, na.action="warn", \dots)
\method{is.multitype}{default}(\dots)  
\method{is.multitype}{quad}(X, na.action="warn", \dots)
is.poisson.interact(x)
is.poisson.ppm(x)
is.prime(n)
is.stationary.ppm(x)    
km.rs(o, cc, d, breaks)
kstestEngine(model, covariate, \dots, jitter, modelname, covname, dataname)
Kborder.engine(X, rmax, nr, correction, weights)
Kount(dIJ, bI, b, breaks)
Kwtsum(dIJ, bI, wIJ, b, w, breaks)
Kmulti.inhom(X, I, J, lambdaI, lambdaJ, \dots,
         r=NULL, breaks=NULL,
         correction = c("border", "isotropic", "Ripley", "translate") ,
         lambdaIJ=NULL,
         Iname = "points satisfying condition I",
         Jname = "points satisfying condition J")
killinteraction(model)
least.common.multiple(n,m)
\method{levels}{im}(x) <- value
lookup.im(Z, x, y, naok)
majorminorversion(v)
make.even.breaks(bmax, npos, bstep)
makeunits(sing, plur, mul)
markformat(x)
\method{markformat}{ppp}(x)
\method{markformat}{psp}(x)
markspace.integral(X)
marks(x, \dots)
\method{marks}{ppp}(x, \dots, dfok)           
\method{marks}{psp}(x, \dots, dfok)
\method{marks}{quad}(x, dfok=FALSE, \dots)
marks(x, \dots) <- value
\method{marks}{ppp}(x, dfok, \dots) <- value
markappendop(x, y)
marksubset(x, index, format)
marksubsetop(x, i)
markreplicateop(x, n)
matcolall(x)
matcolany(x)
matcolsum(x)            
matrixsample(mat, newdim, phase)
matrowall(x)
matrowany(x)
matrowsum(x)
maxflow(costm)
meanX.owin(w)            
meanY.owin(w)
mkcor(d, ff, wt, Ef, rvals, method="smrep", \dots, nwtsteps=500)
mpl.engine(Q, trend, interaction, \dots, covariates, correction,
	 rbord, use.gam, famille,
         forcefit, allcovar, callstring, precomputed, savecomputed, preponly)
mpl.get.covariates(covariates, locations, type)
mpl.prepare(Q, X, P, trend, interaction, covariates, 
            want.trend, want.inter, correction, rbord, Pname,
            callstring, \dots, allcovar, precomputed, savecomputed,
            vnamebase, vnameprefix)
MultiPair.checkmatrix(mat, n, name)
\method{names}{hyperframe}(x)
\method{names}{hyperframe}(x) <- value
nearest.pixel(x, y, im)
newstyle.coeff.handling(object)
no.trend.ppm(x)
n.quad(Q)
numalign(i, nmax, zero)
outdated.interact(object)
overlap.owin(A,B)
overlap.trapezium(xa, ya, xb, yb, verb = FALSE)
overlap.xypolygon(P, Q)
owinpolycheck(W, verbose=TRUE)
param.quad(Q)
paren(x)
pickoption(what="option", key, keymap, \dots,
           exact=FALSE, list.on.err=TRUE, die=TRUE, multi=FALSE)
pixellate(x, \dots, weights)
pixelquad(X, W = as.owin(X))
ploterodewin(W1, W2, col.edge, col.inside, \dots)
ploterodeimage(W, Z, \dots, Wcol, rangeZ, colsZ)
\method{plot}{fii}(x, \dots)
\method{plot}{kstest}(x, \dots)
\method{plot}{minconfit}(x, \dots)
\method{plot}{pppmatching}(x, addmatch = NULL, main = NULL, \dots)
\method{plot}{profilepl}(x, \dots, add=FALSE, main=NULL, tag=TRUE, coeff=NULL, xvariable=NULL)
\method{plot}{qqppm}(x, \dots, limits=TRUE, monochrome=FALSE,
           limcol=if(monochrome) "black" else "red")
\method{plot}{quadratcount}(x, \dots, add, entries, dx, dy)
\method{plot}{quadrattest}(x, \dots)
polynom(x, \dots)
pppdist.mat(X, Y, cutoff = 1, q = 1, matching = TRUE, precision = 9, approximation = 10)
pppdist.prohorov(X, Y, n, dfix, type, cutoff = 1, matching = TRUE, ccode = TRUE, precision = 9, approximation = 10) 
primefactors(n, prmax)
\method{print}{bt.frame}(x, \dots)
\method{print}{diagppm}(x, \dots)
\method{print}{envelope}(x, \dots)
\method{print}{fasp}(x, \dots)
\method{print}{fii}(x, \dots)
\method{print}{fv}(x, \dots)
\method{print}{hyperframe}(x, ...)
\method{print}{interact}(x, \dots, family=TRUE, brief=FALSE)       
\method{print}{isf}(x, \dots)
\method{print}{kppm}(x, \dots)
\method{print}{minconfit}(x, \dots)
\method{print}{plotppm}(x, \dots)
\method{print}{pppmatching}(x, \dots)
\method{print}{profilepl}(x, \dots)
\method{print}{qqppm}(x, \dots)
\method{print}{rmhcontrol}(x, \dots)
\method{print}{rmhmodel}(x, \dots)
\method{print}{rmhstart}(x, \dots)
\method{print}{rmhseed}(x, \dots)
\method{print}{summary.fii}(x, \dots)
\method{print}{summary.hyperframe}(x, ...)
\method{print}{summary.listof}(x, \dots)
\method{print}{summary.owin}(x, \dots)
\method{print}{summary.ppp}(x, \dots, dp=3)
\method{print}{summary.psp}(x, \dots)
\method{print}{summary.splitppp}(x, \dots)
\method{print}{summary.units}(x, \dots)
\method{print}{units}(x, \dots)
prolongseq(x, newrange)
quad(data, dummy, w, param)
quadrat.breaks(xr, yr, nx = 5, ny = nx, xbreaks = NULL, ybreaks = NULL)
quadrat.countEngine(x, y, xbreaks, ybreaks, weights)
quadrat.testEngine(X, nx, ny, xbreaks, ybreaks, \dots, fit=NULL, Xname=NULL, fitname=NULL)
quadscheme.replicated(data, dummy, method = "grid", \dots)
quadscheme.spatial(data, dummy, method = "grid", \dots)
pointgrid(W, ngrid)
rasterx.im(x)
rastery.im(x)
\method{reach}{fii}(x, \dots, epsilon)
rebound.ppp(x, \dots)
rebound.psp(x, \dots)
rebound.owin(w, rect)
reincarnate.interact(object)
\method{rescale}{units}(X,s)
resid4plot(RES, plot.neg="image", plot.smooth="imagecontour",
           spacing=0.1, srange=NULL,monochrome=FALSE, main=NULL, \dots)
resid1plot(RES, opt, plot.neg="image", plot.smooth="imagecontour",
              srange=NULL, monochrome=FALSE, main=NULL, \dots)
resid1panel(observedX, observedV,
            theoreticalX, theoreticalV, theoreticalSD, xlab,ylab, \dots)
resolve.defaults(\dots, .StripNull=FALSE)
restrict.mask(M, W)
reverse.xypolygon(p)
revcumsum(x)
rmax.rule(fun, W, lambda)
rotxy(X, angle = pi/2)
rmhResolveTypes(model, start, control)
\method{rmhcontrol}{rmhcontrol}(control, \dots)
\method{rmhcontrol}{list}(control, \dots)
rmhEngine(InfoList, \dots, verbose, reseed, kitchensink, preponly) 
\method{rmhmodel}{rmhmodel}(model, \dots)
rmhseed(iseed)
\method{rmhstart}{rmhstart}(start, \dots)
\method{rmhstart}{list}(start, \dots)
rmpoint.I.allim(n, f, types)
\method{row.names}{hyperframe}(x)
\method{row.names}{hyperframe}(x) <- value
rpoint.multi(n, f, fmax=NULL, marks = NULL, win = unit.square(), giveup = 1000, verbose = FALSE)
runifpoispp(lambda, win = owin(c(0, 1), c(0, 1)))
runifrect(n, win = owin(c(0, 1), c(0, 1)))
safelookup(Z, X, factor, warn)
second.moment.calc(x, sigma=NULL, edge=TRUE, what="Kmeasure", debug=FALSE,
\dots, varcov=NULL)
shiftxy(X, vec = c(0, 0))
spatstat.rawdata.location(\dots)             
sp.foundclass(cname, inlist, formalname, argsgiven)             
sp.foundclasses(cnames, inlist, formalname, argsgiven)             
stratrand(window, nx, ny, k = 1)
suffloc(object)
suffstat.generic(model, X, callstring)
suffstat.poisson(model, X, callstring)
\method{summary}{envelope}(object,\dots)
\method{summary}{fii}(object,\dots)
\method{summary}{hyperframe}(object, ..., brief=FALSE)
\method{summary}{profilepl}(object, \dots)
\method{summary}{pppmatching}(object, \dots)
\method{summary}{units}(object, \dots)
sympoly(x, y, n)
\method{terms}{ppm}(x, \dots)
\method{terms}{kppm}(x, \dots)
termsinformula(x)
test.crossing.psp(A,B)
test.selfcrossing.psp(A)
tilecentroids(W, nx, ny)
trim.mask(M, R)
\method{unitname}{default}(x)
\method{unitname}{default}(x) <- value
\method{update}{interact}(object, \dots)
valid.ppm(object, na.value)
validate.mask(w, fatal=TRUE)        
validate.quad(Q, fatal, repair, announce)
variablesinformula(x)
versionstring.interact(object)
versionstring.ppm(object)
versionstring.spatstat()
verifyclass(X, C, N = deparse(substitute(X)), fatal = TRUE)
verify.xypolygon(p, fatal=TRUE)
whist(x,breaks,weights, trim, right)
w.quad(Q)               
x.quad(Q)
y.quad(Q)
xypolyselfint(p, eps, proper, yesorno, checkinternal)
xypolygon2psp(p, w)
}

\details{
  These are usually not to be called by the user.
}
\keyword{internal}
